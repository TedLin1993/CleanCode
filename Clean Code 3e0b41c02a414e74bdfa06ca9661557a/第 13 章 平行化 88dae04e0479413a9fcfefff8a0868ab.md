# 第 13 章 平行化

> 物件是處理過程的抽象化，執行緒是排程的抽象化
> 

# **為什麼要平行化？**

平行化將「做什麼」和「何時做」分解開來，或改善應用程式的產能和結構。

需要平行化的例子：

(1) 考慮寫某程式拜訪與解析多個網頁並整合成一份摘要。若只用單一執行緒，將需要逐一拜訪網頁，解析一個網頁後，才能拜訪另一網頁，若網頁的清單過長，最終會使得該程式無法在24小時內完成。此時，我們需要同時拜訪多個網頁來改善此程式效能。

(2) 若處理一位使用者的需求需要一秒鐘 ，使用者數量少時，還可以符合反應時間的要求。但使用者數量增加到150個時，反應時間將變得無法接受。

## 平行化的簡短聲明

- **平行化會帶來額外負擔**, 額外負擔包含程式效能與撰寫額外的程式碼
- **正確的平行化是複雜的**, 即便要解決的是很簡單的問題
- **平行化程式的錯誤通常不容易重複出現**, 所以這些錯誤常因為只出現一次而被忽略
- 平行化常常會要求對於設計策略進行根本性的修改

# **挑戰**

例子

```java
public class X
{
    private int lastIdUsed;
 
    public int getNextIntId()
    {
        return ++lastIdUsed;
    }
}
```

我們先建立X的實體，並設定lastIdUsed為42。考慮有兩個執行緒共享X的實體，將會有三種可能的結果：

(1) Thread 1得到43；Thread 2得到44；最終lastIdUsed為44。

(2) Thread 1得到44；Thread 2得到43；最終lastIdUsed為44。

(3) Thread 1得到43；Thread 2得到43；最終lastIdUsed為43。

對於getNextIntId執行的兩個執行緒而言，會有上萬種可能的執行路徑，在附錄A有詳盡的解釋。但值得注意的是，就算是簡短的++lastIdUsed敘述，都可能被其他執行緒中斷，也就是這簡短的指令並非atomic。

這問題在於，大部分的執行路徑是正確的，但有一部分的路徑會產生錯誤的結果。

# **平行化的防禦原則**

## **單一職責原則**

平行化設計本身已經複雜到足以成為一個修改的理由，因此值得和其餘的程式碼有所劃分。

**建議: 保持你的平行化相關程式碼與其他程式有清楚的劃分。**

## **推論：限制資料的視野**

兩個執行緒修改共享物件的同一個欄位，就會互相干擾。

可用關鍵字 synchronized (同步化) 關鍵字保護共享物件的臨界區域（critical section）程式碼。

越多更多的地方可以更新共享資料，就越容易產生下列狀況：

- 忘記保護臨界區域
- 確認有效保護，會花上重複工夫
- 除錯困難

建議：資料封裝，限制共享資料的存取次數。

## **推論：使用資料的副本**

複製就可以避免出現共享的情況，可以節省鎖定的時間，會付出額外物件與需要回收垃圾的代價。

## **推論：執行緒應盡可能地獨立運行**

儘量讓每個執行緒有自己的世界，與其他執行緒不共享任何資料。

建議：試著將資料劃分成可以讓獨立執行緒操作的獨立子集合。

# **了解你的函數庫**

Java5提供許多平行化開發的改善，應注意下列幾點：

- 使用函式庫所提供的安全執行緒集合（thread-safe collections）
- 使用executor框架來執行不相關的工作
- 盡可能使用非鎖定（nonblocking）的解法
- 有幾個函數庫類別並不提供安全執行緒

# 了解你的執行模型

## 生產者-消費者

- 一個或多個生產者Thread建立工作, 並將之放在緩衝區或Queue裡面。然後一個或多個消費者從Queue中取出工作來做。
- Queue是有限資源，Queue有空間生產者才可以寫入；Queue有東西消費者才可以取出。
- 生產者與消費者彼此之間以訊號通知Queue的情況，兩者在執行之前都在等待通知的狀態。

## 讀取者-寫入者

- 一個共享資源主要當做讀取者讀取的資訊來源，也有會被寫入者更新的情況，資料庫讀寫是其中一個例子。
- 加強讀取產能會出現寫入執行緒飢餓，允許資料更新又會影響產能。
- 關鍵點在於如何平衡讀取與寫入的需求，能夠提供合理的產能又能夠避免飢餓的情況。

## 哲學家用餐

執行緒互相爭奪資源的情況，有可能會出現死結、活結、產能以及效能下降的問題。

# 當心同步方法的相依性

**建議: 避免在一個共享物件上使用超過一個方法**

若必須使用超過一個方法，那麼有三種方式去保護你的程式

1. 基於Client端的鎖定：user的code在使用第一個方法前先鎖定server，直到最後一個方法結束為止。
2. 基於Server端的鎖定：server端建立一個可以鎖定server的方法，執行所有方法，然後解鎖。讓Client去呼叫這個新方法。
3. Adapted Server

# **保持同步區塊的簡短**

- synchronized 關鍵字可以製造一個鎖定，程式碼區塊由同一個鎖定防護，確保一次只有單一執行緒會執行區塊內的程式。
- 保護區域過大會導致資源競爭增加，而降低了效能。
- **建議：同步區塊越簡短越好**

# **撰寫正確的關閉(Shut-Down)程式碼是困難的**

- 正確停止很難達成，因為經常遇到死結問題。有的執行緒會持續等待一個永遠不會來的信號（有可能其中一個執行緒掛掉了）。
- **建議:早點思考關於關閉的問題。**

# **測試執行緒程式碼**

**建議:曾經出現錯誤就代表一定有錯誤，不可以忽略錯誤。**

## **將偽造的失敗看作是潛在的執行緒問題**

平行化程式執行的時候有可能會出現偶發錯誤，一定是程式有問題！不可以當做是假的。

建議：不要把系統錯誤當做偶發事件。

## **先讓你的非執行緒程式碼能順利運行**

先考慮單一執行緒的情況，做到單一執行緒正確，再考慮多執行緒的情況。

## **讓你的執行緒是可隨插即用的**

讓你的執行緒程式碼在不同的設定環境都可以運行。

## **讓你的執行緒程式碼是可調校的**

可以調整程式的環境參數，例如執行緒的數量。

## **執行比處理器數量還要多的執行緒**

要測試工作交換(task swapping)的情況，執行緒數量要比處理器或核心數量還要多。當工作交換地越頻繁，就越有機會找到遺漏的bug。

## **在不同的平台上運行**

平行化程式要在不同的作業系統上進行測試。

## **調整你的程式碼，使之試圖產生失敗或強制產生失敗**

- 如何抓到偶爾會發生的錯誤？在程式增加測試函數影響執行順序，可以增加錯誤發生的機率。有問題的程式碼能夠越早發現是比較好的情況。
- 有兩個替程式碼加工的方法：手動撰寫與自動化

### **手動撰寫**

- 手動撰寫測試程式會遇到一些問題
    - 必須找到合適的地方插入測試程式
    - 要放置合種測試函數
    - 測試程式會影響程式執行的速度
    - 能不能找到錯誤要看運氣

### **自動化**

- 透過 Aspect-Oriented Framework (剖面導向框架)、CGLIB 或 ASM 。
- 可以想像類別有兩種實作，第一種實作測試程式什麼都不做，第二種測試程式會出現影響力，製造各種測試條件。

# **總結**

- 多執行緒與共享資料設計讓平行化程式變困難。
- 程式要分成與執行緒有關與執行緒無關的部分，與執行緒有關的程式要更加短小。
- 平行化可能發現的問題
    - 多執行緒操作共享資料
    - 使用公共資源
    - 邊界情況，例如關閉程式。
- 找出必須被鎖定的區域，不要鎖定過多的區域。避免從一個鎖定區域呼叫另一個鎖定區域。
- 了解哪些東西可以被共享。控制共享物件的數量，縮小共享的視野。
- 將共享的資料提供給客戶端，而不是強迫客戶端來管理共享資料的狀態。
- 平行化程式有可能隨機性出現錯誤。
- 測試程式要有隨插即用的能力。
- 程式碼加工寫測試程式可增加找到錯誤程式的機率。可以手動撰寫或使用自動化科技工具。